<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>server/api/core/core.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="FS.Store.GridFS.html">GridFS</a></li></ul><h3>Namespaces</h3><ul><li><a href="FS.TempStore.html">TempStore</a><ul class='methods'><li data-type='method'><a href="FS.TempStore.html#.createReadStream">createReadStream</a></li><li data-type='method'><a href="FS.TempStore.html#.createWriteStream">createWriteStream</a></li><li data-type='method'><a href="FS.TempStore.html#.exists">exists</a></li><li data-type='method'><a href="FS.TempStore.html#.listParts">listParts</a></li><li data-type='method'><a href="FS.TempStore.html#.removeAll">removeAll</a></li><li data-type='method'><a href="FS.TempStore.html#.removeFile">removeFile</a></li></ul></li><li><a href="Hooks.Events.html">Events</a><ul class='methods'><li data-type='method'><a href="Hooks.Events.html#.add">add</a></li><li data-type='method'><a href="Hooks.Events.html#.remove">remove</a></li><li data-type='method'><a href="Hooks.Events.html#.run">run</a></li><li data-type='method'><a href="Hooks.Events.html#.runAsync">runAsync</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#%2522cart/addToCart%2522">"cart/addToCart"</a></li><li><a href="global.html#%2522cart/copyCartToOrder%2522">"cart/copyCartToOrder"</a></li><li><a href="global.html#%2522cart/createCart%2522">"cart/createCart"</a></li><li><a href="global.html#%2522cart/mergeCart%2522">"cart/mergeCart"</a></li><li><a href="global.html#%2522cart/removeFromCart%2522">"cart/removeFromCart"</a></li><li><a href="global.html#%2522cart/resetShipmentMethod%2522">"cart/resetShipmentMethod"</a></li><li><a href="global.html#%2522cart/setPaymentAddress%2522">"cart/setPaymentAddress"</a></li><li><a href="global.html#%2522cart/setShipmentAddress%2522">"cart/setShipmentAddress"</a></li><li><a href="global.html#%2522cart/setShipmentMethod%2522">"cart/setShipmentMethod"</a></li><li><a href="global.html#%2522cart/setUserCurrency%2522">"cart/setUserCurrency"</a></li><li><a href="global.html#%2522cart/submitPayment%2522">"cart/submitPayment"</a></li><li><a href="global.html#%2522cart/unsetAddresses%2522">"cart/unsetAddresses"</a></li><li><a href="global.html#%2522email/saveSettings%2522">"email/saveSettings"</a></li><li><a href="global.html#%2522email/verifySettings%2522">"email/verifySettings"</a></li><li><a href="global.html#%2522emails/retryFailed%2522">"emails/retryFailed"</a></li><li><a href="global.html#%2522group/addUser%2522">"group/addUser"</a></li><li><a href="global.html#%2522group/createGroup%2522">"group/createGroup"</a></li><li><a href="global.html#%2522group/removeUser%2522">"group/removeUser"</a></li><li><a href="global.html#%2522group/updateGroup%2522">"group/updateGroup"</a></li><li><a href="global.html#%2522i18n/addTranslation%2522">"i18n/addTranslation"</a></li><li><a href="global.html#%2522i18n/flushTranslations%2522">"i18n/flushTranslations"</a></li><li><a href="global.html#%2522products/archiveProduct%2522">"products/archiveProduct"</a></li><li><a href="global.html#%2522products/cloneProduct%2522">"products/cloneProduct"</a></li><li><a href="global.html#%2522products/cloneVariant%2522">"products/cloneVariant"</a></li><li><a href="global.html#%2522products/createProduct%2522">"products/createProduct"</a></li><li><a href="global.html#%2522products/createVariant%2522">"products/createVariant"</a></li><li><a href="global.html#%2522products/deleteVariant%2522">"products/deleteVariant"</a></li><li><a href="global.html#%2522products/publishProduct%2522">"products/publishProduct"</a></li><li><a href="global.html#%2522products/removeMetaFields%2522">"products/removeMetaFields"</a></li><li><a href="global.html#%2522products/removeProductTag%2522">"products/removeProductTag"</a></li><li><a href="global.html#%2522products/setHandle%2522">"products/setHandle"</a></li><li><a href="global.html#%2522products/setHandleTag%2522">"products/setHandleTag"</a></li><li><a href="global.html#%2522products/toggleVisibility%2522">"products/toggleVisibility"</a></li><li><a href="global.html#%2522products/updateMetaFields%2522">"products/updateMetaFields"</a></li><li><a href="global.html#%2522products/updateProductField%2522">"products/updateProductField"</a></li><li><a href="global.html#%2522products/updateProductPosition%2522">"products/updateProductPosition"</a></li><li><a href="global.html#%2522products/updateProductTags%2522">"products/updateProductTags"</a></li><li><a href="global.html#%2522products/updateVariant%2522">"products/updateVariant"</a></li><li><a href="global.html#%2522products/updateVariantsPosition%2522">"products/updateVariantsPosition"</a></li><li><a href="global.html#%2522reaction/getUserId%2522">"reaction/getUserId"</a></li><li><a href="global.html#%2522shop/createShop%2522">"shop/createShop"</a></li><li><a href="global.html#%2522shop/createTag%2522">"shop/createTag"</a></li><li><a href="global.html#%2522shop/fetchCurrencyRate%2522">"shop/fetchCurrencyRate"</a></li><li><a href="global.html#%2522shop/flushCurrencyRate%2522">"shop/flushCurrencyRate"</a></li><li><a href="global.html#%2522shop/getCurrencyRates%2522">"shop/getCurrencyRates"</a></li><li><a href="global.html#%2522shop/getLocale%2522">"shop/getLocale"</a></li><li><a href="global.html#%2522shop/getWorkflow%2522">"shop/getWorkflow"</a></li><li><a href="global.html#%2522shop/hideHeaderTag%2522">"shop/hideHeaderTag"</a></li><li><a href="global.html#%2522shop/locateAddress%2522">"shop/locateAddress"</a></li><li><a href="global.html#%2522shop/removeHeaderTag%2522">"shop/removeHeaderTag"</a></li><li><a href="global.html#%2522shop/updateBrandAssets%2522">"shop/updateBrandAssets"</a></li><li><a href="global.html#%2522shop/updateCurrencyConfiguration%2522">"shop/updateCurrencyConfiguration"</a></li><li><a href="global.html#%2522shop/updateHeaderTags%2522">"shop/updateHeaderTags"</a></li><li><a href="global.html#%2522shop/updateLanguageConfiguration%2522">"shop/updateLanguageConfiguration"</a></li><li><a href="global.html#%2522shop/updateShopExternalServices%2522">"shop/updateShopExternalServices"</a></li><li><a href="global.html#%2522workflow/coreOrderWorkflow/coreOrderCompleted%2522">"workflow/coreOrderWorkflow/coreOrderCompleted"</a></li><li><a href="global.html#%2522workflow/coreOrderWorkflow/coreOrderProcessing%2522">"workflow/coreOrderWorkflow/coreOrderProcessing"</a></li><li><a href="global.html#addressBookAdd">addressBookAdd</a></li><li><a href="global.html#addressBookRemove">addressBookRemove</a></li><li><a href="global.html#addressBookUpdate">addressBookUpdate</a></li><li><a href="global.html#addRolesToGroups">addRolesToGroups</a></li><li><a href="global.html#addUserPermissions">addUserPermissions</a></li><li><a href="global.html#assignOwnerRoles">assignOwnerRoles</a></li><li><a href="global.html#changeMarketplaceOwner">changeMarketplaceOwner</a></li><li><a href="global.html#compareAddress">compareAddress</a></li><li><a href="global.html#compileHandlebarsTemplate">compileHandlebarsTemplate</a></li><li><a href="global.html#copyMedia">copyMedia</a></li><li><a href="global.html#createFallbackLoginToken">createFallbackLoginToken</a></li><li><a href="global.html#createHandle">createHandle</a></li><li><a href="global.html#createTitle">createTitle</a></li><li><a href="global.html#denormalize">denormalize</a></li><li><a href="global.html#doRightJoinNoIntersection">doRightJoinNoIntersection</a></li><li><a href="global.html#flushQuantity">flushQuantity</a></li><li><a href="global.html#GeoCoder">GeoCoder</a></li><li><a href="global.html#getCartItem">getCartItem</a></li><li><a href="global.html#getCurrentShop">getCurrentShop</a></li><li><a href="global.html#getCurrentShopCursor">getCurrentShopCursor</a></li><li><a href="global.html#getMailConfig">getMailConfig</a></li><li><a href="global.html#getMailUrl">getMailUrl</a></li><li><a href="global.html#getMarketplaceSettings">getMarketplaceSettings</a></li><li><a href="global.html#getRegistryDomain">getRegistryDomain</a></li><li><a href="global.html#getRouteName">getRouteName</a></li><li><a href="global.html#getSessionCarts">getSessionCarts</a></li><li><a href="global.html#getSlug">getSlug</a></li><li><a href="global.html#getSubject">getSubject</a></li><li><a href="global.html#getTemplate">getTemplate</a></li><li><a href="global.html#getTemplateFile">getTemplateFile</a></li><li><a href="global.html#getUser">getUser</a></li><li><a href="global.html#getValidator">getValidator</a></li><li><a href="global.html#Hook">Hook</a></li><li><a href="global.html#inviteShopMember">inviteShopMember</a></li><li><a href="global.html#inviteShopOwner">inviteShopOwner</a></li><li><a href="global.html#isBackorder">isBackorder</a></li><li><a href="global.html#isLowQuantity">isLowQuantity</a></li><li><a href="global.html#isSoldOut">isSoldOut</a></li><li><a href="global.html#loadCoreTranslations">loadCoreTranslations</a></li><li><a href="global.html#loadSettings">loadSettings</a></li><li><a href="global.html#loadTranslation">loadTranslation</a></li><li><a href="global.html#loadTranslations">loadTranslations</a></li><li><a href="global.html#metaField">metaField</a></li><li><a href="global.html#methods">methods</a></li><li><a href="global.html#ordersInventoryAdjust">ordersInventoryAdjust</a></li><li><a href="global.html#productVariant">productVariant</a></li><li><a href="global.html#quantityProcessing">quantityProcessing</a></li><li><a href="global.html#randomProcessor">randomProcessor</a></li><li><a href="global.html#Reaction">Reaction</a></li><li><a href="global.html#removeMedia">removeMedia</a></li><li><a href="global.html#resetRegisteredTemplates">resetRegisteredTemplates</a></li><li><a href="global.html#send">send</a></li><li><a href="global.html#sendResetPasswordEmail">sendResetPasswordEmail</a></li><li><a href="global.html#sendVerificationEmail">sendVerificationEmail</a></li><li><a href="global.html#sendWelcomeEmail">sendWelcomeEmail</a></li><li><a href="global.html#ServerSessions">ServerSessions</a></li><li><a href="global.html#setUserPermissions">setUserPermissions</a></li><li><a href="global.html#toDenormalize">toDenormalize</a></li><li><a href="global.html#transform">transform</a></li><li><a href="global.html#updateMediaPriorities">updateMediaPriorities</a></li><li><a href="global.html#updateVariantProductField">updateVariantProductField</a></li><li><a href="global.html#user">user</a></li><li><a href="global.html#validateAddress">validateAddress</a></li><li><a href="global.html#verifyAccount">verifyAccount</a></li><li><a href="global.html#verifyConfig">verifyConfig</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">server/api/core/core.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import url from "url";
import packageJson from "/package.json";
import { merge, uniqWith } from "lodash";
import _ from "lodash";
import { Meteor } from "meteor/meteor";
import { check, Match } from "meteor/check";
import { Random } from "meteor/random";
import { Accounts } from "meteor/accounts-base";
import { Roles } from "meteor/alanning:roles";
import { EJSON } from "meteor/ejson";
import { Jobs, Packages, Shops, Groups } from "/lib/collections";
import { Hooks, Logger } from "/server/api";
import ProcessJobs from "/server/jobs";
import { registerTemplate } from "./templates";
import { sendVerificationEmail } from "./accounts";
import { getMailUrl } from "./email/config";


export default {

  init() {
    // make sure the default shop has been created before going further
    while (!this.getShopId()) {
      Logger.warn("No shopId, waiting one second...");
      Meteor._sleepForMs(1000);
    }

    // run onCoreInit hooks
    Hooks.Events.run("onCoreInit");

    // start job server
    Jobs.startJobServer(() => {
      Logger.info("JobServer started");
      ProcessJobs();
      Hooks.Events.run("onJobServerStart");
    });
    if (process.env.VERBOSE_JOBS) {
      Jobs.setLogStream(process.stdout);
    }
    this.loadPackages();
    // process imports from packages and any hooked imports
    this.Import.flush();
    this.createDefaultGroups();
    // timing is important, packages are rqd for initial permissions configuration.
    if (!Meteor.isAppTest) {
      this.createDefaultAdminUser();
    }
    this.setAppVersion();
    // hook after init finished
    Hooks.Events.run("afterCoreInit");

    Logger.debug("Reaction.init() has run");

    return true;
  },

  Packages: {},

  registerPackage(packageInfo) {
    const registeredPackage = this.Packages[packageInfo.name] = packageInfo;
    return registeredPackage;
  },
  createDefaultGroups(options = {}) {
    const { shopId } = options;
    const allGroups = Groups.find({}).fetch();
    const query = {};

    if (shopId) {
      query._id = shopId;
    }

    const shops = Shops.find(query).fetch();
    const ownerRoles = Roles.getAllRoles().fetch().map(role => role.name);
    const shopManagerRoles = ownerRoles.filter(role => role !== "owner");

    const roles = {
      "shop manager": shopManagerRoles,
      "customer": [ "guest", "account/profile", "product", "tag", "index", "cart/checkout", "cart/completed"],
      "guest": ["anonymous", "guest", "product", "tag", "index", "cart/checkout", "cart/completed"],
      "owner": ownerRoles
    };

    if (shops &amp;&amp; shops.length) {
      shops.forEach(shop => createGroupsForShop(shop));
    }
    function createGroupsForShop(shop) {
      Object.keys(roles).forEach(groupKeys => {
        const groupExists = allGroups.find(grp => grp.slug === groupKeys &amp;&amp; grp.shopId === shop._id);
        if (!groupExists) { // create group only if it doesn't exist before
          Logger.debug(`creating group ${groupKeys} for shop ${shop.name}`);
          Groups.insert({
            name: groupKeys,
            slug: groupKeys,
            permissions: roles[groupKeys],
            shopId: shop._id
          });
        }
      });
    }
  },
  /**
   * registerTemplate
   * registers Templates into the Templates Collection
   * @return {function} Registers template
   */
  registerTemplate: registerTemplate,

  /**
   * hasPermission - server
   * server permissions checks
   * hasPermission exists on both the server and the client.
   * @param {String | Array} checkPermissions -String or Array of permissions if empty, defaults to "admin, owner"
   * @param {String} userId - userId, defaults to Meteor.userId()
   * @param {String} checkGroup group - default to shopId
   * @return {Boolean} Boolean - true if has permission
   */
  hasPermission(checkPermissions, userId = Meteor.userId(), checkGroup = this.getShopId()) {
    // check(checkPermissions, Match.OneOf(String, Array)); check(userId, String); check(checkGroup,
    // Match.Optional(String));

    let permissions;
    // default group to the shop or global if shop isn't defined for some reason.
    let group;
    if (checkGroup !== undefined &amp;&amp; typeof checkGroup === "string") {
      group = checkGroup;
    } else {
      group = this.getShopId() || Roles.GLOBAL_GROUP;
    }

    // permissions can be either a string or an array we'll force it into an array and use that
    if (checkPermissions === undefined) {
      permissions = ["owner"];
    } else if (typeof checkPermissions === "string") {
      permissions = [checkPermissions];
    } else {
      permissions = checkPermissions;
    }

    // if the user has admin, owner permissions we'll always check if those roles are enough
    permissions.push("owner");
    permissions = _.uniq(permissions);

    // return if user has permissions in the group
    if (Roles.userIsInRole(userId, permissions, group)) {
      return true;
    }

    // global roles check
    const sellerShopPermissions = Roles.getGroupsForUser(userId, "admin");

    // we're looking for seller permissions.
    if (sellerShopPermissions) {
      // loop through shops roles and check permissions
      for (const key in sellerShopPermissions) {
        if (key) {
          const shop = sellerShopPermissions[key];
          if (Roles.userIsInRole(userId, permissions, shop)) {
            return true;
          }
        }
      }
    }
    // no specific permissions found returning false
    return false;
  },

  hasOwnerAccess() {
    return this.hasPermission(["owner"]);
  },

  hasAdminAccess() {
    return this.hasPermission(["owner", "admin"]);
  },

  hasDashboardAccess() {
    return this.hasPermission(["owner", "admin", "dashboard"]);
  },

  getSellerShopId() {
    return Roles.getGroupsForUser(this.userId, "admin");
  },

  configureMailUrl() {
    // maintained for legacy support
    Logger.warn("Reaction.configureMailUrl() is deprecated. Please use Reaction.Email.getMailUrl() instead");
    return getMailUrl();
  },

  getPrimaryShop() {
    const primaryShop = Shops.findOne({
      shopType: "primary"
    });

    return primaryShop;
  },

  // primaryShopId is the first created shop. In a marketplace setting it's
  // the shop that controls the marketplace and can see all other shops.
  getPrimaryShopId() {
    const primaryShop = this.getPrimaryShop();
    if (primaryShop) {
      return primaryShop._id;
    }
  },

  getPrimaryShopName() {
    const primaryShop = this.getPrimaryShop();
    if (primaryShop) {
      return primaryShop.name;
    }
    // If we can't find the primaryShop return an empty string
    return "";
  },

  // Primary Shop should probably not have a prefix (or should it be /shop?)
  getPrimaryShopPrefix() {
    return "/" + this.getSlug(this.getPrimaryShopName().toLowerCase());
  },

  getPrimaryShopSettings() {
    const settings = Packages.findOne({
      name: "core",
      shopId: this.getPrimaryShopId()
    }) || {};
    return settings.settings || {};
  },

  getPrimaryShopCurrency() {
    const primaryShop = this.getPrimaryShop();

    if (primaryShop &amp;&amp; primaryShop.currency) {
      return primaryShop.currency;
    }

    return "USD";
  },

  /**
   * **DEPRECATED** This method has been deprecated in favor of using getShopId
   * and getPrimaryShopId. To be removed.
   * @deprecated
   * @method getCurrentShopCursor
   * @return {Cursor} cursor of shops that match the current domain
   */
  getCurrentShopCursor() {
    const domain = this.getDomain();
    const cursor = Shops.find({
      domains: domain
    });
    if (!cursor.count()) {
      Logger.debug(domain, "Add a domain entry to shops for ");
    }
    return cursor;
  },

  /**
   * **DEPRECATED** This method has been deprecated in favor of using getShopId
   * and getPrimaryShopId. To be removed.
   * @deprecated
   * @method getCurrentShop
   * @return {Object} returns the first shop object from the shop cursor
   */
  getCurrentShop() {
    const currentShopCursor = this.getCurrentShopCursor();
    // also, we could check in such a way: `currentShopCursor instanceof Object` but not instanceof something.Cursor
    if (typeof currentShopCursor === "object") {
      return currentShopCursor.fetch()[0];
    }
    return null;
  },

  getShopId(userId) {
    check(userId, Match.Maybe(String));
    const activeUserId = Meteor.call("reaction/getUserId");
    if (activeUserId || userId) {
      const activeShopId = this.getUserPreferences({
        userId: activeUserId || userId,
        packageName: "reaction",
        preference: "activeShopId"
      });
      if (activeShopId) {
        return activeShopId;
      }
    }

    // TODO: This should intelligently find the correct default shop
    // Probably whatever the main shop is or the marketplace
    const domain = this.getDomain();
    const shop = Shops.find({
      domains: domain
    }, {
      limit: 1,
      fields: {
        _id: 1
      }
    }).fetch()[0];
    return shop &amp;&amp; shop._id;
  },

  getDomain() {
    return url.parse(Meteor.absoluteUrl()).hostname;
  },

  getShopName() {
    const shopId = this.getShopId();
    let shop;
    if (shopId) {
      shop = Shops.findOne({
        _id: shopId
      }, {
        fields: {
          name: 1
        }
      });
    } else {
      const domain = this.getDomain();
      shop = Shops.findOne({
        domains: domain
      }, {
        fields: {
          name: 1
        }
      });
    }
    if (shop &amp;&amp; shop.name) {
      return shop.name;
    }
    // If we can't find the shop or shop name return an empty string
    // so that string methods that rely on getShopName don't error
    return "";
  },

  getShopPrefix() {
    const shopName = this.getShopName();
    const lowerCaseShopName = shopName.toLowerCase();
    const slug = this.getSlug(lowerCaseShopName);
    return `/${slug}`;
  },

  getShopEmail() {
    const shop = Shops.find({
      _id: this.getShopId()
    }, {
      limit: 1,
      fields: {
        emails: 1
      }
    }).fetch()[0];
    return shop &amp;&amp; shop.emails &amp;&amp; shop.emails[0].address;
  },

  getShopSettings(name = "core") {
    const settings = Packages.findOne({ name: name, shopId: this.getShopId() }) || {};
    return settings.settings || {};
  },

  getShopCurrency() {
    const shop = Shops.findOne({
      _id: this.getShopId()
    });

    return shop &amp;&amp; shop.currency || "USD";
  },

  // TODO: Marketplace - should each shop set their own default language or
  // should the Marketplace set a language that's picked up by all shops?
  getShopLanguage() {
    const { language } = Shops.findOne({
      _id: this.getShopId()
    }, {
      fields: {
        language: 1
      } }
    );
    return language;
  },

  getPackageSettings(name) {
    return Packages.findOne({ name: name, shopId: this.getShopId() }) || null;
  },

  /**
   * getMarketplaceSettings finds the enabled `reaction-marketplace` package for
   * the primary shop and returns the settings
   * @method getMarketplaceSettings
   * @return {Object} The marketplace settings from the primary shop or undefined
   */
  getMarketplaceSettings() {
    const marketplace = Packages.findOne({
      name: "reaction-marketplace",
      shopId: this.getPrimaryShopId(),
      enabled: true
    });

    if (marketplace &amp;&amp; marketplace.settings) {
      return marketplace.settings;
    }
    return {};
  },

  // options:  {packageName, preference, defaultValue}
  getUserPreferences(options) {
    const { userId, packageName, preference, defaultValue } = options;

    if (!userId) {
      return undefined;
    }

    const user = Meteor.users.findOne({ _id: userId });

    if (user) {
      const profile = user.profile;
      if (profile &amp;&amp; profile.preferences &amp;&amp; profile.preferences[packageName] &amp;&amp; profile.preferences[packageName][preference]) {
        return profile.preferences[packageName][preference];
      }
    }
    return defaultValue || undefined;
  },

  /**
   *  insertPackagesForShop
   *  insert Reaction packages into Packages collection registry for a new shop
   *  Assigns owner roles for new packages
   *  Imports layouts from packages
   *  @param {String} shopId - the shopId to create packages for
   *  @return {String} returns insert result
   */
  insertPackagesForShop(shopId) {
    const layouts = [];
    if (!shopId) {
      return [];
    }

    // Check to see what packages should be enabled
    const shop = Shops.findOne({ _id: shopId });
    const marketplaceSettings = this.getMarketplaceSettings();
    let enabledPackages;

    // Unless we have marketplace settings and an enabledPackagesByShopTypes Array
    // we will skip this
    if (marketplaceSettings &amp;&amp;
        marketplaceSettings.shops &amp;&amp;
        Array.isArray(marketplaceSettings.shops.enabledPackagesByShopTypes)) {
      // Find the correct packages list for this shopType
      const matchingShopType = marketplaceSettings.shops.enabledPackagesByShopTypes.find(
        EnabledPackagesByShopType => EnabledPackagesByShopType.shopType === shop.shopType);
      if (matchingShopType) {
        enabledPackages = matchingShopType.enabledPackages;
      }
    }

    const packages = this.Packages;
    // for each shop, we're loading packages in a unique registry
    // Object.keys(pkgConfigs).forEach((pkgName) => {
    for (const packageName in packages) {
      // Guard to prvent unexpected `for in` behavior
      if ({}.hasOwnProperty.call(packages, packageName)) {
        const config = packages[packageName];
        this.assignOwnerRoles(shopId, packageName, config.registry);

        const pkg = Object.assign({}, config, {
          shopId: shopId
        });

        // populate array of layouts that don't already exist (?!)
        if (pkg.layout) {
          // filter out layout templates
          for (const template of pkg.layout) {
            if (template &amp;&amp; template.layout) {
              layouts.push(template);
            }
          }
        }

        if (enabledPackages &amp;&amp; Array.isArray(enabledPackages)) {
          if (enabledPackages.indexOf(pkg.name) === -1) {
            pkg.enabled = false;
          }
        }
        Packages.insert(pkg);
        Logger.debug(`Initializing ${shopId} ${packageName}`);
      }
    }

    // helper for removing layout duplicates
    const uniqLayouts = uniqWith(layouts, _.isEqual);
    Shops.update({ _id: shopId }, { $set: { layout: uniqLayouts } });
  },

  getAppVersion() {
    return Shops.findOne().appVersion;
  },

  /**
   * createDefaultAdminUser
   * @summary Method that creates default admin user
   * Settings load precendence:
   *  1. environment variables
   *  2. settings in meteor.settings
   * @returns {String} return userId
   */
  createDefaultAdminUser() {
    const shopId = this.getPrimaryShopId();

    // if an admin user has already been created, we'll exit
    if (Roles.getUsersInRole("owner", shopId).count() !== 0) {
      Logger.debug("Not creating default admin user, already exists");
      return ""; // this default admin has already been created for this shop.
    }

    // run hooks on options object before creating user (the options object must be returned from all callbacks)
    let options = {};
    options = Hooks.Events.run("beforeCreateDefaultAdminUser", options);

    // If $REACTION_SECURE_DEFAULT_ADMIN is set to "true" on first run,
    // a random email/password will be generated instead of using the
    // default email and password (email: admin@localhost pw: r3@cti0n)
    // and the new admin user will need to verify their email to log in.
    // If a random email and password are generated, the console will be
    // the only place to retrieve them.
    // If the admin email/password is provided via environment or Meteor settings,
    // the $REACTION_SECURE_DEFAULT_ADMIN will only enforce the email validation part.
    const isSecureSetup = process.env.REACTION_SECURE_DEFAULT_ADMIN === "true";

    // generate default values to use if none are supplied
    const defaultEmail = isSecureSetup ? `${Random.id(8).toLowerCase()}@localhost` : "admin@localhost";
    const defaultPassword = isSecureSetup ? Random.secret(8) : "r3@cti0n";
    const defaultUsername = "admin";
    const defaultName = "Admin";

    // Process environment variables and Meteor settings for initial user config.
    // If ENV variables are set, they always override Meteor settings (settings.json).
    // This is to allow for testing environments where we don't want to use users configured in a settings file.
    const env = process.env;
    let configureEnv = false;

    if (env.REACTION_EMAIL &amp;&amp; env.REACTION_AUTH) {
      configureEnv = true;
      Logger.info("Using environment variables to create admin user");
    }

    // defaults use either env or generated values
    options.email = env.REACTION_EMAIL || defaultEmail;
    options.password = env.REACTION_AUTH || defaultPassword;
    options.username = env.REACTION_USER_NAME || defaultUsername;
    options.name = env.REACTION_USER || defaultName;

    // or use `meteor --settings`
    if (Meteor.settings &amp;&amp; !configureEnv) {
      if (Meteor.settings.reaction) {
        options.email = Meteor.settings.reaction.REACTION_EMAIL || defaultEmail;
        options.password = Meteor.settings.reaction.REACTION_AUTH || defaultPassword;
        options.username = Meteor.settings.reaction.REACTION_USER || defaultUsername;
        options.name = Meteor.settings.reaction.REACTION_USER_NAME || defaultName;
        Logger.info("Using meteor --settings to create admin user");
      }
    }

    // set the default shop email to the default admin email
    Shops.update(shopId, {
      $addToSet: {
        emails: {
          address: options.email,
          verified: true
        }
      }
    });

    // get the current shop
    const shop = Shops.findOne(shopId);

    // add the current domain to the shop if it doesn't already exist
    if (!shop.domains.includes(this.getDomain())) {
      // set the default shop email to the default admin email
      Shops.update(shopId, {
        $addToSet: {
          domains: this.getDomain()
        }
      });
    }

    //
    // create the new admin user
    //
    let accountId;
    // we're checking again to see if this user was created but not specifically for this shop.
    if (Meteor.users.find({ "emails.address": options.email }).count() === 0) {
      accountId = Accounts.createUser(options);
    } else {
      // this should only occur when existing admin creates a new shop
      accountId = Meteor.users.findOne({ "emails.address": options.email })._id;
    }

    // update the user's name if it was provided
    // (since Accounts.createUser() doesn't allow that field and strips it out)
    Meteor.users.update(accountId, {
      $set: {
        name: options.name
      }
    });

    // unless strict security is enabled, mark the admin's email as validated
    if (!isSecureSetup) {
      Meteor.users.update({
        "_id": accountId,
        "emails.address": options.email
      }, {
        $set: {
          "emails.$.verified": true
        }
      });
    } else {
      // send verification email to admin
      sendVerificationEmail(accountId);
    }

    //
    // Set Default Roles
    //
    const defaultAdminRoles = ["owner", "admin", "guest", "account/profile"];
    // we don't use accounts/addUserPermissions here because we may not yet have permissions
    Roles.setUserRoles(accountId, defaultAdminRoles, shopId);
    // // the reaction owner has permissions to all sites by default
    Roles.setUserRoles(accountId, defaultAdminRoles, Roles.GLOBAL_GROUP);
    // initialize package permissions we don't need to do any further permission configuration it is taken care of in the
    // assignOwnerRoles
    const packages = Packages.find().fetch();
    for (const pkg of packages) {
      this.assignOwnerRoles(shopId, pkg.name, pkg.registry);
    }

    // notify user that the default admin was created by
    // printing the account info to the console
    Logger.warn(`\n *********************************
        \n  IMPORTANT! DEFAULT ADMIN INFO
        \n  EMAIL/LOGIN: ${options.email}
        \n  PASSWORD: ${options.password}
        \n ********************************* \n\n`);

    // run hooks on new user object
    const user = Meteor.users.findOne(accountId);
    Hooks.Events.run("afterCreateDefaultAdminUser", user);

    return accountId;
  },

  /**
   *  loadPackages
   *  insert Reaction packages into registry
   *  we check to see if the number of packages have changed against current data
   *  if there is a change, we'll either insert or upsert package registry
   *  into the Packages collection
   *  import is processed on hook in init()
   *  @return {String} returns insert result
   */
  loadPackages() {
    const packages = Packages.find().fetch();

    let registryFixtureData;

    if (process.env.REACTION_REGISTRY) {
      // check the environment for the registry fixture data first
      registryFixtureData = process.env.REACTION_REGISTRY;
      Logger.info("Loaded REACTION_REGISTRY environment variable for registry fixture import");
    } else {
      // or attempt to load reaction.json fixture data
      try {
        registryFixtureData = Assets.getText("settings/reaction.json");
        Logger.info("Loaded \"/private/settings/reaction.json\" for registry fixture import");
      } catch (error) {
        Logger.warn("Skipped loading settings from reaction.json.");
        Logger.debug(error, "loadSettings reaction.json not loaded.");
      }
    }

    if (!!registryFixtureData) {
      const validatedJson = EJSON.parse(registryFixtureData);

      if (!Array.isArray(validatedJson[0])) {
        Logger.warn("Registry fixture data is not an array. Failed to load.");
      } else {
        registryFixtureData = validatedJson;
      }
    }

    const layouts = [];
    // for each shop, we're loading packages in a unique registry
    _.each(this.Packages, (config, pkgName) => {
      return Shops.find().forEach((shop) => {
        const shopId = shop._id;
        if (!shopId) return [];

        // existing registry will be upserted with changes, perhaps we should add:
        this.assignOwnerRoles(shopId, pkgName, config.registry);

        // Settings from the package registry.js
        const settingsFromPackage = {
          name: pkgName,
          icon: config.icon,
          enabled: !!config.autoEnable,
          settings: config.settings,
          registry: config.registry,
          layout: config.layout
        };

        // Setting from a fixture file, most likely reaction.json
        let settingsFromFixture;
        if (registryFixtureData) {
          settingsFromFixture = _.find(registryFixtureData[0], (packageSetting) => {
            return config.name === packageSetting.name;
          });
        }

        // Setting already imported into the packages collection
        const settingsFromDB = _.find(packages, (ps) => {
          return (config.name === ps.name &amp;&amp; shopId === ps.shopId);
        });

        const combinedSettings = merge({}, settingsFromPackage, settingsFromFixture || {}, settingsFromDB || {});

        // populate array of layouts that don't already exist in Shops
        if (combinedSettings.layout) {
          // filter out layout Templates
          for (const pkg of combinedSettings.layout) {
            if (pkg.layout) {
              layouts.push(pkg);
            }
          }
        }
        // Import package data
        this.Import.package(combinedSettings, shopId);
        return Logger.debug(`Initializing ${shop.name} ${pkgName}`);
      }); // end shops
    });

    // helper for removing layout duplicates
    const uniqLayouts = uniqWith(layouts, _.isEqual);
    // import layouts into Shops
    Shops.find().forEach((shop) => {
      this.Import.layout(uniqLayouts, shop._id);
    });

    //
    // package cleanup
    //
    Shops.find().forEach((shop) => {
      return Packages.find().forEach((pkg) => {
        // delete registry entries for packages that have been removed
        if (!_.has(this.Packages, pkg.name)) {
          Logger.debug(`Removing ${pkg.name}`);
          return Packages.remove({ shopId: shop._id, name: pkg.name });
        }
        return false;
      });
    });
  },
  setAppVersion() {
    const version = packageJson.version;
    Logger.info(`Reaction Version: ${version}`);
    Shops.update({}, { $set: { appVersion: version } }, { multi: true });
  }
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.3</a> on Wed Aug 09 2017 11:56:59 GMT-0700 (PDT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
